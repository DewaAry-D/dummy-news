const { Op, fn, col, where } = require("sequelize");

class NewsService {
    constructor(NewsModel, ContentNewsModel, VisitorLogModel) {
        this.News = NewsModel;
        this.ContentNews = ContentNewsModel;
        this.VisitorLog = VisitorLogModel
    }

    async getTrendingNews() {
        try {
            const last24Hours = new Date(new Date() - 24 * 60 * 60 * 1000);

            const trending = await this.News.findAll({
                attributes: [
                    'id',
                    'title',
                    'slug',
                    'category',
                    'imagePath',
                    'authorName',
                    'createdAt',
                    [fn('COUNT', col('visits.id')), 'totalViews']
                ],
                include: [{
                    model: this.VisitorLog,
                    as: 'visits',
                    attributes: [],
                    where: {
                        visitedAt: {
                            [Op.gt]: last24Hours
                        }
                    },
                    required: true 
                }],
                group: ['News.id'],
                order: [[fn('COUNT', col('visits.id')), 'DESC']],
                limit: 10, 
                subQuery: false 
            });

            return trending;
        } catch (error) {
            console.error("Error fetching trending news:", error);
            throw error;
        }
    }

    async getUniqueCategories() {
        const categories = await this.News.findAll({
            attributes: [
                [fn('DISTINCT', col('category')), 'category']
            ],
            raw: true
        });
        return categories.map(item => item.category).filter(Boolean);
    }

    async getRecommendationNews(category) {
        return this.News.findAll({
            where: {
                category
            },
            limit: 5,
            order: [['createdAt', 'DESC']]
        })
    }

    //for all
    async getAllPosts({ offset = 0, limit = 10, title = '', category = '', status = '' }) {
        const validStatuses = ['PUBLISHED', 'ARCHIVED', 'DRAFT'];
        const where = {};

        if (status && validStatuses.includes(status)) {
            where.status = status;
        }
        if (title) {
            where.title = { [Op.like]: `%${title}%` };
        }
        if (category) {
            where.category = category;
        }

        return await this.News.findAndCountAll({
            where: where,
            limit: limit,
            offset: offset,
            order: [['createdAt', 'DESC']]
        });
    }

    //forUser
    async getPostBySlug(slug) {
        return this.News.findOne({
            where: { slug, status: 'PUBLISHED' },
            include: [{
                model: this.ContentNews,
                as: 'contentBlocks',
                order: [['order', 'ASC']]
            }]
        });
    }

    //forAdmin

    async getPostBySlugForAdmin(slug) {
        return this.News.findOne({
            where: { slug },
            include: [{
                model: this.ContentNews,
                as: 'contentBlocks',
                order: [['order', 'ASC']]
            }]
        });
    }

    // async createPost(newsData, contentBlocks, files) {
    //     return this.News.sequelize.transaction(async (t) => {
    //         const rawPath = files['thumbnailImage']?.[0]?.path;
    //         newsData.imagePath = rawPath 
    //             ? rawPath.replace(/\\/g, '/').replace(/^public/, '') 
    //             : null;
    //         const newsItem = await this.News.create(newsData, { transaction: t });

    //         let blocks = [];
    //         let count = 0;
    //         contentBlocks.forEach((element, index) => {
    //             console.log(element);
    //             if (element.blockType == "IMAGE") {
    //                 const rawPathE = files['contentImages']?.[count]?.path;
    //                 element.contentValue = rawPathE.replace(/\\/g, '/').replace(/^public/, '');
    //                 count++;
    //             }
    //             element.newsId = newsItem.id;
    //             element.order = index + 1;
    //             blocks.push(element);
    //         });


    //         await this.ContentNews.bulkCreate(blocks, { transaction: t });
    //         return newsItem;
    //     });
    // }

    async createPost(newsData, contentBlocks, fileUrls) {
        return this.News.sequelize.transaction(async (t) => {
            
            // 1. SET THUMBNAIL
            // Langsung ambil URL dari object yang dikirim controller.
            // Tidak perlu replace regex lagi karena URL dari Vercel Blob sudah bersih (https://...)
            newsData.imagePath = fileUrls.thumbnailImage || null;
            
            const newsItem = await this.News.create(newsData, { transaction: t });

            let blocks = [];
            let count = 0;

            // 2. SET CONTENT BLOCKS
            // Pastikan contentBlocks adalah array
            if (contentBlocks && Array.isArray(contentBlocks)) {
                contentBlocks.forEach((element, index) => {
                    
                    // Clone element agar tidak memutasi object asli secara tidak sengaja (optional tapi good practice)
                    let blockData = { ...element }; 

                    if (blockData.blockType == "IMAGE") {
                        // Ambil URL dari array contentImages berdasarkan urutan (count)
                        const imageUrl = fileUrls.contentImages?.[count];
                        
                        // Simpan URL langsung ke contentValue
                        blockData.contentValue = imageUrl || null;
                        
                        count++;
                    }

                    blockData.newsId = newsItem.id;
                    blockData.order = index + 1;
                    blocks.push(blockData);
                });
            }

            await this.ContentNews.bulkCreate(blocks, { transaction: t });
            return newsItem;
        });
    }

    // async updatePost(id, newsData, contentBlocks, files) {
    //     return this.News.sequelize.transaction(async (t) => {
    //         const oldNews = await this.News.findByPk(id, {
    //             include: [{ model: this.ContentNews, as: 'contentBlocks' }],
    //             transaction: t
    //         });

    //         if (!oldNews) throw new Error("Berita tidak ditemukan");

    //         let filesToDelete = [];

    //         if (files['thumbnailImage']?.[0]) {
    //             if (oldNews.imagePath) filesToDelete.push(oldNews.imagePath);
    //             const rawPath = files['thumbnailImage'][0].path;
    //             // newsData.imagePath = rawPath.replace(/\\/g, '/');
    //             newsData.imagePath = rawPath.replace(/\\/g, '/').replace(/^public/, '');
    //         } else {
    //             newsData.imagePath = oldNews.imagePath;
    //         }

    //         await oldNews.update(newsData, { transaction: t });

    //         const oldBlocks = oldNews.contentBlocks || [];

    //         await this.ContentNews.destroy({
    //             where: { newsId: id },
    //             transaction: t
    //         });

    //         let blocks = [];
    //         let imageCount = 0;

    //         contentBlocks.forEach((element, index) => {
    //             if (element.blockType === "IMAGE") {
    //                 const newFile = files['contentImages']?.[imageCount];

    //                 if (newFile) {
    //                     const rawPathE = newFile.path;
    //                     // element.contentValue = rawPathE.replace(/\\/g, '/');
    //                     element.contentValue = rawPathE.replace(/\\/g, '/').replace(/^public/, '');
    //                     imageCount++;
    //                 } else {
    //                     element.contentValue = element.contentValue;
    //                 }
    //             }

    //             element.newsId = id;
    //             element.order = index + 1;
    //             blocks.push(element);
    //         });

    //         await this.ContentNews.bulkCreate(blocks, { transaction: t });

    //         return { newsItem: oldNews, filesToDelete };
    //     });
    // }

    async updatePost(id, newsData, contentBlocks, fileUrls) {
        return this.News.sequelize.transaction(async (t) => {
            // 1. Ambil Data Lama
            const oldNews = await this.News.findByPk(id, {
                include: [{ model: this.ContentNews, as: 'contentBlocks' }],
                transaction: t
            });

            if (!oldNews) throw new Error("Berita tidak ditemukan");

            // 2. Logic Update Thumbnail
            // Jika Controller mengirim URL thumbnail baru, pakai itu.
            // Jika null, biarkan (jangan di-update), atau gunakan data lama.
            if (fileUrls.thumbnailImage) {
                newsData.imagePath = fileUrls.thumbnailImage;
            } else {
                // Hapus key imagePath dari newsData agar Sequelize tidak meng-update field ini dengan null
                // Ini memastikan gambar lama tetap aman.
                delete newsData.imagePath; 
            }

            // Update Table News
            await oldNews.update(newsData, { transaction: t });

            // 3. Logic Update Content Blocks
            // Strategy: Hapus semua block lama, insert ulang block baru (termasuk gambar lama/baru)
            await this.ContentNews.destroy({
                where: { newsId: id },
                transaction: t
            });

            let blocks = [];
            let newImageCount = 0; // Counter untuk mengambil URL dari array fileUrls.contentImages

            if (contentBlocks && Array.isArray(contentBlocks)) {
                contentBlocks.forEach((element, index) => {
                    // Clone element agar aman
                    let blockData = { ...element };

                    if (blockData.blockType === "IMAGE") {
                        // Cek apakah blok ini mendapat giliran gambar BARU yang diupload
                        // Logikanya: Frontend mengirim file hanya untuk gambar yang diganti/baru.
                        // Jadi kita cek antrian di fileUrls.contentImages
                        
                        /* Skenario 1: User upload gambar baru. 
                        Maka kita ambil URL dari fileUrls.contentImages[newImageCount].
                        */
                    
                        /* Skenario 2: User TIDAK upload gambar (mempertahankan gambar lama).
                        Maka blockData.contentValue biasanya masih berisi URL lama (dikirim dari frontend).
                        Dan fileUrls.contentImages tidak akan punya stok untuk index ini (atau dilewati).
                        */

                        // LOGIKA: Prioritaskan gambar baru jika tersedia di antrian upload
                        // Anda mungkin perlu menyesuaikan logika ini tergantung bagaimana Frontend mengirim datanya.
                        // Asumsi: Frontend mengirim 'contentValue' kosong jika upload baru.
                        
                        if (fileUrls.contentImages && fileUrls.contentImages[newImageCount] && (!blockData.contentValue || blockData.contentValue === '')) {
                            blockData.contentValue = fileUrls.contentImages[newImageCount];
                            newImageCount++;
                        } 
                        // Jika tidak ada upload baru, kita asumsikan blockData.contentValue 
                        // sudah berisi URL gambar lama (karena dikirim ulang oleh frontend di req.body)
                    }

                    blockData.newsId = id;
                    blockData.order = index + 1;
                    delete blockData.id; // Hapus ID agar terhitung sebagai entri baru

                    blocks.push(blockData);
                });
            }

            await this.ContentNews.bulkCreate(blocks, { transaction: t });

            // Return newsItem saja, tidak perlu filesToDelete karena kita tidak pakai fs.unlink
            return oldNews;
        });
    }

    async updateStatusNews(id, status) {
        const news = await this.News.findByPk(id);
        if (!news) throw new Error("Berita tidak ditemukan");

        await news.update({
            status: status
        });

        return news;
    }

    //belum selesai
    async deletePost(id) {
        return this.News.destroy({ where: { id } });
    }

    async dashboardAdmin(currentYear) {
        const newsCount = await this.News.count();

        const monthlyVisitors = await this.VisitorLog.findAll({
            attributes: [
                [fn('MONTH', col('visitedAt')), 'month'],
                [fn('COUNT', col('id')), 'total']
            ],
            where: where(fn('YEAR', col('visitedAt')), currentYear),
            group: [fn('MONTH', col('visitedAt'))],
            raw: true
        });

        const totalYearlyVisitors = await this.VisitorLog.count({
            where: where(fn('YEAR', col('visitedAt')), currentYear)
        });

        const categoryCount = await this.News.count({
            distinct: true,
            col: 'category'
        });

        return { newsCount, categoryCount, monthlyVisitors, totalYearlyVisitors };
    }
}

module.exports = NewsService;